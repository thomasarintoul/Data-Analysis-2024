<html>
<head>
<title>CDT_CA_miniproject.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #676773;}
.s1 { color: #c9c9d1;}
.s2 { color: #e0957b;}
.s3 { color: #c9c9d1;}
.s4 { color: #62a362;}
.s5 { color: #4dacf0;}
.s6 { color: #e0957b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1d1d26">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
CDT_CA_miniproject.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
</span><span class="s1">##### CDT Data Analysis 2022 - Coursework (100%) 
# Analysing gravitational wave signals  
## Deadline Jan 27th, 4pm. 
</span><span class="s0">#%% md 
</span><span class="s1">#### &lt;div class = &quot;tip&quot;&gt;Instructions&lt;/div&gt; 
</span><span class="s0">#%% md 
</span><span class="s1">Please ensure you have read the information in the **background_info** folder before starting this coursework.  
</span><span class="s0">#%% md 
</span><span class="s1">**These assessments are equivalent to an exam**: 
- Submit your work (.ipynb file) via email to the module organiser. Note that you must make sure your notebook compiles fully and that all supporting files that may be included are added to your email. 
- Don't worry about how your code looks - marks are not given for pretty code, but rather for the approach used in solving the problem, your reasoning, explanation and answer. 
- Please also take note of your Universityâ€™s policy on **plagiarism**. 
</span><span class="s0">#%% md 
</span><span class="s1">#### &lt;div class = &quot;tip&quot;&gt;Tips&lt;/div&gt; 
 
</span><span class="s0">#%% md 
</span><span class="s1">- Explain all your reasoning for each step. A *significant fraction* of the marks are given for explanations and discussion, as they evidence understanding of the analysis.   
- Some of these steps will take a while to run and compile. It's a good idea to add in print statements to your code throughout eg `print('this step is done')` to make sure that your bit of code has finished. 
- Add the import packages statements at the top of your Jupyter notebook. We will use the `pandas` package to read in the data, with eg `dataIn=pd.read_csv('filename.csv')`. 
</span><span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">Gravitational waves are disturbances in the curvature of spacetime, generated by accelerated masses, that propagate as waves outward from their source at the speed of light.  They are predicted in General Relativity and other theories of gravity and since 2017, they have now been observed! 
 
In this exercise we will analyse some mock gravitational wave data from two unknown astrophysical objects merging together and coelescing. We will use a Monte Carlo Markov Chain (MCMC) to compare a scaled model that predicts how the wave changes depending on the total mass of the merging objects and their distance from us to the observed waveform.  This will allow us to determine the nature of the orbiting objects that merged to form the gravitational wave using MCMC, whether for instance they could be originating from merging white dwarfs, neutron stars or black holes. 
 
The mock or simulated waveforms measure the strain as two compact, dense astrophysical objects coalesce. The strain describes the amplitude of the wave. The system is parameterised by the masses of the merging objects, $M_1$ and $M_2$, and their distance from the observer $D$.   
 
Other useful parameters and equations relevant for this assessment are given in the background information folder. 
</span><span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">## Part A - The data 
 
1. Read in the datafile of the observed waveform `Observedwaveform.csv`. These files store the strain as a function of &quot;GPS time&quot; for the merger of two bodies.  
 
2. The GPS time of the merger for your waveform is 1205951542.153363.  Your data will need to be shifted so that the merger occurs at time = 0 secs.  This is required as we will compare our data with a which have the merger at t=0s.  
 
3. We need to estimate the average noise and its standard deviation in our data. This requires careful thought about where the noise can be seen in the waveform.    
</span><span class="s0">#%% md 
</span><span class="s1">**Answer:** 
</span><span class="s0">#%% md 
</span><span class="s1">*Your answer here* 
</span><span class="s0">#%% md 
</span><span class="s1"># Part A - Answers 
## 1 
As stated in Chapter 8, the frequency of the inspiral signal depends on the chirp mass of the two objects merging. 
This chirp mass is given by: 
$$M_{ch} = \dfrac{(M_1 M_2)^{3/5}}{(M_1 + M_2)^{1/5}}.$$ 
 
The observed signal's associated chirp mass required black holes to be involved rather than neutron stars. 
 
This could still allow a BH-NS merger, however unbalanced masses, i.e. a mass ratio $q = M_2/M_1 \ll 1.0$, give a signal with a consistently oscillating amplitude as the objects orbit each other. This was not seen in 2015, suggesting a mass ratio closer to 1. 
 
Combined with the chirp mass, this requires 2 Black Holes. 
</span><span class="s0">#%% md 
</span><span class="s1">## 2 
 
</span><span class="s0">#%% 
</span><span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">scipy </span><span class="s2">as </span><span class="s1">sc</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s0">#%% 
</span><span class="s1">data_events </span><span class="s3">= </span><span class="s1">pd.read_csv(</span><span class="s4">'Observedwaveform.csv'</span><span class="s1">)</span>
<span class="s1">data_events[</span><span class="s4">'time (s)'</span><span class="s1">] </span><span class="s3">= </span><span class="s1">data_events[</span><span class="s4">'time (s)'</span><span class="s1">] </span><span class="s3">- </span><span class="s5">1205951542.153363</span>
<span class="s1">data_events.head()</span>
<span class="s0">#%% md 
</span><span class="s1"># 3 
</span><span class="s0">#%% 
</span><span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(data_events[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">data_events[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Observed Waveform'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper right'</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">Noise can be seen after the merger. Will take the noisy section as any data after t = 0.01s 
</span><span class="s0">#%% 
# select noisy data</span>
<span class="s1">noise </span><span class="s3">= </span><span class="s1">data_events.loc[np.where(data_events[</span><span class="s4">'time (s)'</span><span class="s1">] </span><span class="s3">&gt; </span><span class="s5">0.01</span><span class="s1">)]</span>
<span class="s1">noise</span>
<span class="s0">#%% 
</span><span class="s1">noise_mean </span><span class="s3">= </span><span class="s1">np.mean(noise[</span><span class="s4">'strain'</span><span class="s1">])</span>
<span class="s1">noise_std </span><span class="s3">= </span><span class="s1">np.std(noise[</span><span class="s4">'strain'</span><span class="s1">])</span>

<span class="s1">print(</span><span class="s4">'noise mean ='</span><span class="s6">, </span><span class="s1">noise_mean)</span>
<span class="s1">print(</span><span class="s4">'noise_std  ='</span><span class="s6">, </span><span class="s1">noise_std)</span>
<span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">## Part B - Using model waveforms to estimate the total mass and distance to the system &quot;a by-eye estimate&quot;)  
 
In this part of the question we will attempt to produce a waveform for any mass and distance values using a reference waveform with $M=40 M_{sun}$, $D=1$Mpc and $q=M_2/M_1 = 1$ and scaling it by any new mass and/or distance.     
 
The reference waveform/template we will use is```reference_Mtot40Msun_Dist1Mpc.csv```.  
 
You will need to follow the steps below when answering this question: 
 
1. Open the reference/template file using the `pandas` package. Write a function in python to scale the time and strain of any waveform with $q=1$, total mass $M$ and distance $D$ from the reference waveform file ```reference_Mtot40Msun_Dist1Mpc.csv``` using the equations for how the waveform strain and time depends on mass and distance from the Background_info_mini_project.ipynb notebook.  
 
2. Test your function works by substituting in $M=70\,M_{sun}$ and $D=5$Mpc, and compare your resulting waveform with the template in `reference_Mtot70Msun_Dist5Mpc.csv`.  Comment on your result.  
  
3. Use your function to scale the template waveform ($M=40 M_{sun}$, $D=1$Mpc) to make an initial rough estimate &quot;by eye&quot; of the total mass and distance that &quot;best&quot; fits your data (e.g. to within +/- 5 Msun, +/- 100 Mpc).  
</span><span class="s0">#%% md 
</span><span class="s1">**Answer:** 
</span><span class="s0">#%% md 
</span><span class="s1">*Your answer here* 
</span><span class="s0">#%% md 
</span><span class="s1">1. Open the reference/template file using the `pandas` package. Write a function in python to scale the time and strain of any waveform with $q=1$, total mass $M$ and distance $D$ from the reference waveform file ```reference_Mtot40Msun_Dist1Mpc.csv``` using the equations for how the waveform strain and time depends on mass and distance from the Background_info_mini_project.ipynb notebook. 
</span><span class="s0">#%% 
</span><span class="s1">reference_waveform </span><span class="s3">= </span><span class="s1">pd.read_csv(</span><span class="s4">'reference_Mtot40Msun_Dist1Mpc.csv'</span><span class="s1">)</span>
<span class="s1">reference_waveform.head()</span>
<span class="s0">#%% 
</span><span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(reference_waveform[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">reference_waveform[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Reference Waveform'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper right'</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">From the notes, this is the template equation: 
 
$$ 
h(t,M,D) = \left(\dfrac{M}{M_{\rm {ref}}}\right) \left(\dfrac{D_{\rm {ref}}}{D}\right) h(t_{\rm {ref}})  
$$ 
 
where: 
 
$$ t_{\rm {ref}}=\left(\dfrac{M_{\rm {ref}}}{M}\right)t  $$  
</span><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">h(t</span><span class="s6">, </span><span class="s1">M</span><span class="s6">, </span><span class="s1">D)</span><span class="s3">:</span>
    <span class="s1">M_ref </span><span class="s3">= </span><span class="s5">40 </span><span class="s0"># Msol</span>
    <span class="s1">D_ref </span><span class="s3">= </span><span class="s5">1  </span><span class="s0"># Mpc</span>
    <span class="s1">t_ref </span><span class="s3">= </span><span class="s1">(M_ref </span><span class="s3">/ </span><span class="s1">M) </span><span class="s3">* </span><span class="s1">t</span>
    <span class="s1">ref </span><span class="s3">= </span><span class="s1">pd.read_csv(</span><span class="s4">'reference_Mtot40Msun_Dist1Mpc.csv'</span><span class="s1">)</span>
    <span class="s1">closest_ind </span><span class="s3">= </span><span class="s1">np.abs(ref[</span><span class="s4">'time (s)'</span><span class="s1">].values </span><span class="s3">- </span><span class="s1">t_ref).argmin()</span>
    <span class="s1">h_tref </span><span class="s3">= </span><span class="s1">ref[</span><span class="s4">'strain'</span><span class="s1">][closest_ind]</span>
    <span class="s2">return </span><span class="s1">(M </span><span class="s3">/ </span><span class="s1">M_ref) </span><span class="s3">* </span><span class="s1">(D_ref </span><span class="s3">/ </span><span class="s1">D) </span><span class="s3">* </span><span class="s1">h_tref</span>

<span class="s0">#%% md 
</span>
<span class="s0">#%% md 
</span><span class="s1">2. Test your function works by substituting in $M=70\,M_{sun}$ and $D=5$Mpc, and compare your resulting waveform with the template in `reference_Mtot70Msun_Dist5Mpc.csv`.  Comment on your result.  
</span><span class="s0">#%% 
</span><span class="s1">test_waveform </span><span class="s3">= </span><span class="s1">pd.read_csv(</span><span class="s4">'reference_Mtot70Msun_Dist5Mpc.csv'</span><span class="s1">)</span>
<span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(test_waveform[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">test_waveform[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Test Waveform'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper right'</span><span class="s1">)</span>
<span class="s0">#%% 
</span><span class="s1">t_min </span><span class="s3">= </span><span class="s1">test_waveform[</span><span class="s4">'time (s)'</span><span class="s1">].min()</span>
<span class="s1">t_max </span><span class="s3">= </span><span class="s1">test_waveform[</span><span class="s4">'time (s)'</span><span class="s1">].max()</span>
<span class="s1">t </span><span class="s3">= </span><span class="s1">np.linspace(t_min</span><span class="s6">,</span><span class="s1">t_max</span><span class="s6">,</span><span class="s5">2000</span><span class="s1">)</span>
<span class="s1">scaled_ref </span><span class="s3">= </span><span class="s1">[h(time</span><span class="s6">, </span><span class="s1">M</span><span class="s3">=</span><span class="s5">70</span><span class="s6">, </span><span class="s1">D</span><span class="s3">=</span><span class="s5">5</span><span class="s1">) </span><span class="s2">for </span><span class="s1">time </span><span class="s2">in </span><span class="s1">t]</span>
<span class="s0">#%% 
</span><span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(test_waveform[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">test_waveform[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Test Waveform'</span><span class="s1">)</span>
<span class="s1">plt.plot(t</span><span class="s6">, </span><span class="s1">scaled_ref</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'crimson'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Scaled'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper left'</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">3. Use your function to scale the template waveform ($M=40 M_{sun}$, $D=1$Mpc) to make an initial rough estimate &quot;by eye&quot; of the total mass and distance that &quot;best&quot; fits your data (e.g. to within +/- 5 Msun, +/- 100 Mpc).  
</span><span class="s0">#%% 
</span><span class="s1">t_min_data </span><span class="s3">= </span><span class="s1">data_events[</span><span class="s4">'time (s)'</span><span class="s1">].min()</span>
<span class="s1">t_max_data </span><span class="s3">= </span><span class="s1">data_events[</span><span class="s4">'time (s)'</span><span class="s1">].max()</span>
<span class="s1">t </span><span class="s3">= </span><span class="s1">np.linspace(t_min_data</span><span class="s6">,</span><span class="s1">t_max_data</span><span class="s6">,</span><span class="s5">2000</span><span class="s1">)</span>
<span class="s1">scaled_data </span><span class="s3">= </span><span class="s1">[h(time</span><span class="s6">, </span><span class="s1">M</span><span class="s3">=</span><span class="s5">60</span><span class="s6">, </span><span class="s1">D</span><span class="s3">=</span><span class="s5">1000</span><span class="s1">) </span><span class="s2">for </span><span class="s1">time </span><span class="s2">in </span><span class="s1">t]</span>
<span class="s1">scaled_df </span><span class="s3">= </span><span class="s1">pd.DataFrame(data</span><span class="s3">=</span><span class="s1">t</span><span class="s6">, </span><span class="s1">columns</span><span class="s3">=</span><span class="s1">[</span><span class="s4">'time (s)'</span><span class="s1">])</span>
<span class="s1">scaled_df[</span><span class="s4">'strain'</span><span class="s1">] </span><span class="s3">= </span><span class="s1">scaled_data</span>

<span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(data_events[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">data_events[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Test Waveform'</span><span class="s1">)</span>
<span class="s1">plt.plot(scaled_df[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">scaled_df[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'crimson'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Scaled'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper left'</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">A &quot;by eye&quot; estimate gets the chirp mass to be approx 60 Solar Masses and the merger to have occurred 1000 Mpc away 
</span><span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">## Part C- Get data and model to have the same x values.  
 
Now that we have our observed data, and can scale the template data to any mass and distance, we need to do one more fix.  Currently our data and our templates have different sampling on the $x$ axis - ie they have different values of $x$ (time(.  We need to try and match the $x$ times up so that for each value of $x$ we can compare the $y$ values (the observed strain with the strain from the scaled template).   
 
We need to only consider the times when we have observed data, so we will trim our data set. 
 
1.  Our data waveform starts at some time $t_{\rm min}$. Find out what this is.  Next, take your observed data waveform and output data for $t$ &gt; $t_{\rm min}$ and $t$ &lt; $0$ (ie only keep information for times $\le 0$ (before the merger), or for times where there is data).  Verify, by plotting, that your new observed waveform only has data in this restricted time range.  
 
2. We now need to put both observed and template waveforms on the same time sampling, ie the same number of data points.  The model waveforms have approx 20,000+ time steps, yet the data has less than hundreds in the time range specified!   
 
We need to interpolate between our observed data and the template. To do this use the following code: 
 
(assuming `x[index]` and `y[index]` are the observed data from Part D.1 and scaled template time is your scaled reference template to your suggested values of $M$ and $D$ from Part C3.) 
 
``` 
from scipy.interpolate import interp1d 
 
# get interpolation object using data 
interp_fn =interp1d(x[index],y[index],bounds_error=False) 
 
# now get scaled template and get the strains for the same x axis as data 
interp_strain = interp_fn(scaled_template_time) 
 
#plot 
plt.plot(scaled_template_time,interp_strain) 
``` 
 
Briefly verify that this works.  
 
*Hints:* 
 * *One can use the following code example  `index = np.where((data &gt; 5)&amp;(data &lt; 10))[0]`. This type of statement returns a list of indices (`index`) where the conditions in the bracket have been met.  `data_[index]` pulls out `data` that satisfy the conditions in the brackets above.* 
</span><span class="s0">#%% md 
</span><span class="s1">**Answer** 
</span><span class="s0">#%% md 
</span><span class="s1">*Your answer here* 
</span><span class="s0">#%% 
# select waveform data for times after tmin and pre-merger</span>
<span class="s1">working_data </span><span class="s3">= </span><span class="s1">data_events.copy()</span>
<span class="s1">working_data </span><span class="s3">= </span><span class="s1">working_data.loc[t_min_data </span><span class="s3">&lt; </span><span class="s1">working_data[</span><span class="s4">'time (s)'</span><span class="s1">]]</span>
<span class="s1">working_data </span><span class="s3">= </span><span class="s1">working_data.loc[working_data[</span><span class="s4">'time (s)'</span><span class="s1">] </span><span class="s3">&lt; </span><span class="s5">0.0</span><span class="s1">]</span>

<span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">plt.plot(working_data[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">working_data[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Working Data'</span><span class="s1">)</span>
<span class="s1">plt.legend(loc</span><span class="s3">=</span><span class="s4">'upper left'</span><span class="s1">)</span>
<span class="s0">#%% 
</span><span class="s2">from </span><span class="s1">scipy.interpolate </span><span class="s2">import </span><span class="s1">interp1d</span>

<span class="s0"># get interpolation object using data</span>
<span class="s1">interp_fn </span><span class="s3">=</span><span class="s1">interp1d(working_data[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">,</span><span class="s1">working_data[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">,</span><span class="s1">bounds_error</span><span class="s3">=</span><span class="s2">False</span><span class="s1">)</span>

<span class="s0"># now get scaled template and get the strains for the same x axis as data</span>
<span class="s1">interp_strain </span><span class="s3">= </span><span class="s1">interp_fn(scaled_df[</span><span class="s4">'time (s)'</span><span class="s1">])</span>

<span class="s0">#plot</span>
<span class="s1">plt.figure(figsize</span><span class="s3">=</span><span class="s1">(</span><span class="s5">20</span><span class="s6">,</span><span class="s5">4</span><span class="s1">))</span>

<span class="s1">plt.plot(scaled_df[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">,</span><span class="s1">interp_strain</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'crimson'</span><span class="s1">)</span>
<span class="s1">plt.plot(working_data[</span><span class="s4">'time (s)'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">working_data[</span><span class="s4">'strain'</span><span class="s1">]</span><span class="s6">, </span><span class="s1">color</span><span class="s3">=</span><span class="s4">'dodgerblue'</span><span class="s6">, </span><span class="s1">label</span><span class="s3">=</span><span class="s4">'Working Data'</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% md 
</span><span class="s1">## Part D - Estimating the best fit total mass using MCMC  
 
Now that we know how to make the scaled template (ie 40Msun,1Mpc template file) and the observed data have the same time sampling, we can use MCMC to find out the total mass of the system that made the data we see.   
 
*If you run into any difficulties completing this component of the coursework, you can still attempt the following parts using your by-eye estimates for $M$ and $D$ from Part B.* 
 
Think carefully about what the likelihood function will be in this case (see Chapters 6-9).   
 
1. Use MCMC to sample the total mass, $M$ to produce a best-fit value for your data.  
 
2.  Display the results in an appropriate manner and comment on your findings, as well as your results from the MCMC.  
 
3. Report the median and 90% credible limits on your values.   
  
You may assume that: 
- the noise is described by a Gaussian distribution,  
- the total mass of the system is in the range [20,100] $M_{sun}$. 
  
_Hints:_ 
 
 * _Think very carefully about the form of your likelihood since here we are comparing observed data with a model_ 
  
 * _You should work with &quot;log(Likelihood)&quot; to avoid numerical errors  - note this will affect both your posterior and the step in the MCMC chain where we usually write $p_{\rm proposed}/p_{\rm current}$_ 
 
 * _The step size between samples of the MCMC is quite important. A suggested value for the mass is $0.1\,M_{sun}$_ 
  
 * _The initial guess of your mass is also very important. You may find yourself getting into a local minimum rather than your code finding the true minimum._ 
  
 * _Test your MCMC on a small number of samples (e.g. 10-100) before trying it with a larger number (e.g. $10^5$ or $10^6$)_ 
  
 * _At the end, ask yourself if you need to include every sample?_ 
  
 * _Depending on your step size, this part can take a long time to run. Suggest that you move all your plotting routines to a different code cell to save you re-running everything 10000s of times when you just want to change a plot command._ 
  
 * _To find out how long it will take for a Jupyter notebook to compile the MCMC code cell, add the following snippet to your code before you go into your MCMC loop (where Nsteps is the number of steps your MCMC is using):_ 
  
```def time_spent_waiting(n): 
    from datetime import datetime,timedelta 
    preddur=[n*0.01,n*0.02] 
    print('predicted duration: {:.2f}-{:.2f} mins'.format(preddur[0]/60.,preddur[1]/60.)) 
    return``` 
</span><span class="s0">#%% md 
</span><span class="s1">**Answer:** 
</span><span class="s0">#%% md 
</span><span class="s1">*Your answer here* 
 
 
</span><span class="s0">#%% 
</span><span class="s1">working_data</span>
<span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">h(t</span><span class="s6">, </span><span class="s1">M</span><span class="s6">, </span><span class="s1">D)</span><span class="s3">:</span>
    <span class="s1">M_ref </span><span class="s3">= </span><span class="s5">40 </span><span class="s0"># Msol</span>
    <span class="s1">D_ref </span><span class="s3">= </span><span class="s5">1  </span><span class="s0"># Mpc</span>
    <span class="s1">t_ref </span><span class="s3">= </span><span class="s1">(M_ref </span><span class="s3">/ </span><span class="s1">M) </span><span class="s3">* </span><span class="s1">t</span>
    <span class="s1">ref </span><span class="s3">= </span><span class="s1">pd.read_csv(</span><span class="s4">'reference_Mtot40Msun_Dist1Mpc.csv'</span><span class="s1">)</span>
    <span class="s1">closest_ind </span><span class="s3">= </span><span class="s1">np.abs(ref[</span><span class="s4">'time (s)'</span><span class="s1">].values </span><span class="s3">- </span><span class="s1">t_ref).argmin()</span>
    <span class="s1">h_tref </span><span class="s3">= </span><span class="s1">ref[</span><span class="s4">'strain'</span><span class="s1">][closest_ind]</span>
    <span class="s2">return </span><span class="s1">(M </span><span class="s3">/ </span><span class="s1">M_ref) </span><span class="s3">* </span><span class="s1">(D_ref </span><span class="s3">/ </span><span class="s1">D) </span><span class="s3">* </span><span class="s1">h_tref</span>
<span class="s0">#%% 
</span><span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">norm</span>

<span class="s1">var </span><span class="s3">= </span><span class="s1">np.var(working_data[</span><span class="s4">'strain'</span><span class="s1">])</span>

<span class="s2">def </span><span class="s1">log_likelihood(M</span><span class="s6">, </span><span class="s1">data</span><span class="s6">, </span><span class="s1">variance)</span><span class="s3">:</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s5">1000</span>
    
    <span class="s1">loglike_val </span><span class="s3">= </span><span class="s5">0.0</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(data[</span><span class="s4">'strain'</span><span class="s1">]))</span><span class="s3">:</span>
        <span class="s1">h_obs </span><span class="s3">= </span><span class="s1">data[</span><span class="s4">'strain'</span><span class="s1">].iloc[i]</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">data[</span><span class="s4">'time (s)'</span><span class="s1">].iloc[i]</span>
        <span class="s1">h_model </span><span class="s3">= </span><span class="s1">h(t</span><span class="s6">, </span><span class="s1">M</span><span class="s6">, </span><span class="s1">D)</span>
        <span class="s1">residual </span><span class="s3">= </span><span class="s1">h_obs </span><span class="s3">- </span><span class="s1">h_model</span>
        <span class="s1">chi_squared </span><span class="s3">= </span><span class="s1">np.sum((residual </span><span class="s3">/ </span><span class="s1">variance) </span><span class="s3">** </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">loglike_val </span><span class="s3">+= -</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">chi_squared</span>
    <span class="s2">return </span><span class="s1">loglike_val</span>



<span class="s2">def </span><span class="s1">MCMC_Mass(N_mcmc</span><span class="s6">, </span><span class="s1">M_prior</span><span class="s6">, </span><span class="s1">sigma_mcmc)</span><span class="s3">:</span>
    <span class="s1">M_current </span><span class="s3">= </span><span class="s1">np.zeros(N_mcmc</span><span class="s3">+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">M_current[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">= </span><span class="s1">M_prior</span>
    
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(N_mcmc)</span><span class="s3">:</span>
        <span class="s1">print(i)</span>
        <span class="s1">p_current </span><span class="s3">= </span><span class="s1">log_likelihood(M_current[i]</span><span class="s6">, </span><span class="s1">working_data</span><span class="s6">, </span><span class="s1">var) </span><span class="s0"># put current value in posterior equation</span>
        <span class="s1">dM </span><span class="s3">= </span><span class="s1">np.random.normal(</span><span class="s5">0</span><span class="s6">,</span><span class="s1">sigma_mcmc) </span><span class="s0"># randomally draw a value of theta to trial </span>
        <span class="s1">M_proposed </span><span class="s3">= </span><span class="s1">M_current[i] </span><span class="s3">+ </span><span class="s1">dM </span><span class="s0">#get new proposed theta (random theta + stepsize)</span>
        <span class="s1">p_proposed </span><span class="s3">= </span><span class="s1">log_likelihood(M_proposed</span><span class="s6">, </span><span class="s1">working_data</span><span class="s6">, </span><span class="s1">var) </span><span class="s0"># calculate posterior p for proposed theta</span>
        
        <span class="s0"># #  keep this value if probability proposed theta greater than the current prob</span>
        <span class="s0"># if p_proposed &gt; p_current: </span>
        <span class="s0">#     M_current[i+1] = M_proposed</span>
        <span class="s0"># else:</span>
        <span class="s0"># # if probability lower</span>
        <span class="s0"># # use the ratios of probability to define probability of whether we move to that value or not</span>
        <span class="s0">#     p_new_move = p_proposed - p_current</span>
        <span class="s0">#     # generate random number for probability</span>
        <span class="s0">#     u_random = np.random.uniform(0,1)</span>
        <span class="s0">#     # if u_random &lt; p_new_move, then accept, if not, reject</span>
        <span class="s0">#     if u_random &lt;= p_new_move:</span>
        <span class="s0">#         M_current[i+1] = M_proposed</span>
        <span class="s0">#     else:</span>
        <span class="s0">#         M_current[i+1] = M_current[i]</span>
                
        <span class="s1">p_acceptance </span><span class="s3">= </span><span class="s1">p_proposed </span><span class="s3">- </span><span class="s1">p_current</span>
    
        <span class="s0"># Accept or reject the proposal</span>
        <span class="s2">if </span><span class="s1">p_acceptance </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">np.log(np.random.rand()) </span><span class="s3">&lt; </span><span class="s1">p_acceptance</span><span class="s3">:</span>
            <span class="s1">M_current[i</span><span class="s3">+</span><span class="s5">1</span><span class="s1">] </span><span class="s3">= </span><span class="s1">M_proposed</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">M_current[i</span><span class="s3">+</span><span class="s5">1</span><span class="s1">] </span><span class="s3">= </span><span class="s1">M_current[i]</span>
                
        <span class="s1">print(M_current[i])</span>
    <span class="s2">return </span><span class="s1">M_current</span>


<span class="s0">#%% 
# set up MCMC step paramaters</span>
<span class="s1">N_mcmc </span><span class="s3">= </span><span class="s5">200</span>
<span class="s1">M_prior </span><span class="s3">= </span><span class="s5">60.</span>
<span class="s0"># choose a value for width of normal distribution to get the step in height</span>
<span class="s0"># this is between the prior and the likelihood values</span>
<span class="s1">sigma_mcmc </span><span class="s3">= </span><span class="s5">0.2</span>

<span class="s1">M_current </span><span class="s3">= </span><span class="s1">MCMC_Mass(N_mcmc</span><span class="s6">, </span><span class="s1">M_prior</span><span class="s6">, </span><span class="s1">sigma_mcmc)</span>

<span class="s0"># get mean + std from mcmc generated samples</span>
<span class="s1">mean_mcmc</span><span class="s3">=</span><span class="s1">np.mean(M_current)</span>
<span class="s1">std_mcmc</span><span class="s3">=</span><span class="s1">np.std(M_current)</span>

<span class="s1">print(</span><span class="s4">'The mean Mass from the MCMC is {:.2f} +/- {:.2f} Solar Masses'</span><span class="s1">.format(mean_mcmc</span><span class="s6">,</span><span class="s1">std_mcmc))</span>
<span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% 
</span><span class="s1">plt.plot(M_current)</span>
<span class="s1">plt.xlabel(</span><span class="s4">'Number of Runs'</span><span class="s1">)</span>
<span class="s1">plt.ylabel(</span><span class="s4">'Total Mass'</span><span class="s1">)</span>
<span class="s1">plt.grid()</span>
<span class="s0">#%% md 
</span><span class="s1">## Part E - Putting it all together  
 
If you run into any difficulties completing Part E, you can still attempt this part using your by-eye estimates for $M$ and $D$ from Part B. 
 
1. Calculate the chirp mass for your system and the individual masses of your merging bodies. Comment on your individual masses.  
 
2. Comment on what your analysis suggests are the best astrophysical candidates for the merging objects?  What information are you missing to rule out other astrophysical candidates? 
</span><span class="s0">#%% md 
</span><span class="s1">**Answer:** 
</span><span class="s0">#%% md 
</span><span class="s1">*Your answer here* 
 
 
</span><span class="s0">#%% md 
</span><span class="s1">*** 
</span><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">chirp_mass(M1</span><span class="s6">, </span><span class="s1">M2)</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">(M1 </span><span class="s3">* </span><span class="s1">M2)</span><span class="s3">**</span><span class="s1">(</span><span class="s5">3</span><span class="s3">/</span><span class="s5">5</span><span class="s1">) </span><span class="s3">/ </span><span class="s1">(M1 </span><span class="s3">+ </span><span class="s1">M2)</span><span class="s3">**</span><span class="s1">(</span><span class="s5">1</span><span class="s3">/</span><span class="s5">5</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">Unsure how to get from total mass, M, to the chirp or component masses, however the signal does not appear to vary wildly in peak amplitude over the orbits suggesting that the mass ratio is somewhere closer to 1 than 0. This would imply that the two components are on the order of 30 Solar Masses. 
 
Since the most massive known Neutron Star is estimated to be around 2 Solar Masses, this would imply that the components were stellar mass black holes.</span></pre>
</body>
</html>